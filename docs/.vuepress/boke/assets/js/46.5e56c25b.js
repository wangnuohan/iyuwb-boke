(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{478:function(e,n,t){"use strict";t.r(n);var o=t(53),s=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"long-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#long-js"}},[e._v("#")]),e._v(" long.js")]),e._v(" "),t("p",[e._v("A Long class for representing a 64 bit two's-complement integer value derived from the "),t("a",{attrs:{href:"https://github.com/google/closure-library",target:"_blank",rel:"noopener noreferrer"}},[e._v("Closure Library"),t("OutboundLink")],1),e._v("\nfor stand-alone use and extended with unsigned support.")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.npmjs.com/package/long",target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:"https://img.shields.io/npm/v/long.svg",alt:"npm"}}),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://travis-ci.org/dcodeIO/long.js",target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:"https://travis-ci.org/dcodeIO/long.js.svg",alt:"Build Status"}}),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),t("p",[e._v("As of "),t("a",{attrs:{href:"http://ecma262-5.com/ELS5_HTML.htm#Section_8.5",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMA-262 5th Edition"),t("OutboundLink")],1),e._v(', "all the positive and negative integers\nwhose magnitude is no greater than 2'),t("sup",[e._v("53")]),e._v(' are representable in the Number type", which is "representing the\ndoubleprecision 64-bit format IEEE 754 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic".\nThe '),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER",target:"_blank",rel:"noopener noreferrer"}},[e._v("maximum safe integer"),t("OutboundLink")],1),e._v("\nin JavaScript is 2"),t("sup",[e._v("53")]),e._v("-1.")]),e._v(" "),t("p",[e._v("Example: 2"),t("sup",[e._v("64")]),e._v("-1 is 1844674407370955"),t("strong",[e._v("1615")]),e._v(" but in JavaScript it evaluates to 1844674407370955"),t("strong",[e._v("2000")]),e._v(".")]),e._v(" "),t("p",[e._v('Furthermore, bitwise operators in JavaScript "deal only with integers in the range −2'),t("sup",[e._v("31")]),e._v(" through\n2"),t("sup",[e._v("31")]),e._v("−1, inclusive, or in the range 0 through 2"),t("sup",[e._v("32")]),e._v("−1, inclusive. These operators accept any value of\nthe Number type but first convert each such value to one of 2"),t("sup",[e._v("32")]),e._v(' integer values."')]),e._v(" "),t("p",[e._v("In some use cases, however, it is required to be able to reliably work with and perform bitwise operations on the full\n64 bits. This is where long.js comes into play.")]),e._v(" "),t("h2",{attrs:{id:"usage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#usage"}},[e._v("#")]),e._v(" Usage")]),e._v(" "),t("p",[e._v("The class is compatible with CommonJS and AMD loaders and is exposed globally as "),t("code",[e._v("Long")]),e._v(" if neither is available.")]),e._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" Long "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("require")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"long"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" longVal "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Long")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("0xFFFFFFFF")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x7FFFFFFF")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\nconsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("longVal"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("toString")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n")])])]),t("h2",{attrs:{id:"api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" API")]),e._v(" "),t("h3",{attrs:{id:"constructor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[e._v("#")]),e._v(" Constructor")]),e._v(" "),t("ul",[t("li",[e._v("new "),t("strong",[e._v("Long")]),e._v("(low: "),t("code",[e._v("number")]),e._v(", high: "),t("code",[e._v("number")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v(")"),t("br"),e._v("\nConstructs a 64 bit two's-complement integer, given its low and high 32 bit values as "),t("em",[e._v("signed")]),e._v(" integers. See the from* functions below for more convenient ways of constructing Longs.")])]),e._v(" "),t("h3",{attrs:{id:"fields"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fields"}},[e._v("#")]),e._v(" Fields")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Long#"),t("strong",[e._v("low")]),e._v(": "),t("code",[e._v("number")]),t("br"),e._v("\nThe low 32 bits as a signed value.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("high")]),e._v(": "),t("code",[e._v("number")]),t("br"),e._v("\nThe high 32 bits as a signed value.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("unsigned")]),e._v(": "),t("code",[e._v("boolean")]),t("br"),e._v("\nWhether unsigned or not.")])])]),e._v(" "),t("h3",{attrs:{id:"constants"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#constants"}},[e._v("#")]),e._v(" Constants")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Long."),t("strong",[e._v("ZERO")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nSigned zero.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("ONE")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nSigned one.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("NEG_ONE")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nSigned negative one.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("UZERO")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nUnsigned zero.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("UONE")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nUnsigned one.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("MAX_VALUE")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nMaximum signed value.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("MIN_VALUE")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nMinimum signed value.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("MAX_UNSIGNED_VALUE")]),e._v(": "),t("code",[e._v("Long")]),t("br"),e._v("\nMaximum unsigned value.")])])]),e._v(" "),t("h3",{attrs:{id:"utility"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#utility"}},[e._v("#")]),e._v(" Utility")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Long."),t("strong",[e._v("isLong")]),e._v("(obj: "),t("code",[e._v("*")]),e._v("): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if the specified object is a Long.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromBits")]),e._v("(lowBits: "),t("code",[e._v("number")]),e._v(", highBits: "),t("code",[e._v("number")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is assumed to use 32 bits.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromBytes")]),e._v("(bytes: "),t("code",[e._v("number[]")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v(", le?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nCreates a Long from its byte representation.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromBytesLE")]),e._v("(bytes: "),t("code",[e._v("number[]")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nCreates a Long from its little endian byte representation.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromBytesBE")]),e._v("(bytes: "),t("code",[e._v("number[]")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nCreates a Long from its big endian byte representation.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromInt")]),e._v("(value: "),t("code",[e._v("number")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns a Long representing the given 32 bit integer value.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromNumber")]),e._v("(value: "),t("code",[e._v("number")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromString")]),e._v("(str: "),t("code",[e._v("string")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v(", radix?: "),t("code",[e._v("number")]),e._v(")"),t("br"),e._v("\nLong."),t("strong",[e._v("fromString")]),e._v("(str: "),t("code",[e._v("string")]),e._v(", radix: "),t("code",[e._v("number")]),e._v(")"),t("br"),e._v("\nReturns a Long representation of the given string, written using the specified radix.")])]),e._v(" "),t("li",[t("p",[e._v("Long."),t("strong",[e._v("fromValue")]),e._v("(val: "),t("code",[e._v("*")]),e._v(", unsigned?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nConverts the specified value to a Long using the appropriate from* function for its type.")])])]),e._v(" "),t("h3",{attrs:{id:"methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[e._v("#")]),e._v(" Methods")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Long#"),t("strong",[e._v("add")]),e._v("(addend: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns the sum of this and the specified Long.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("and")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns the bitwise AND of this Long and the specified.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("compare")]),e._v("/"),t("strong",[e._v("comp")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("number")]),t("br"),e._v("\nCompares this Long's value with the specified's. Returns "),t("code",[e._v("0")]),e._v(" if they are the same, "),t("code",[e._v("1")]),e._v(" if the this is greater and "),t("code",[e._v("-1")]),e._v(" if the given one is greater.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("divide")]),e._v("/"),t("strong",[e._v("div")]),e._v("(divisor: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns this Long divided by the specified.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("equals")]),e._v("/"),t("strong",[e._v("eq")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value equals the specified's.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("getHighBits")]),e._v("(): "),t("code",[e._v("number")]),t("br"),e._v("\nGets the high 32 bits as a signed integer.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("getHighBitsUnsigned")]),e._v("(): "),t("code",[e._v("number")]),t("br"),e._v("\nGets the high 32 bits as an unsigned integer.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("getLowBits")]),e._v("(): "),t("code",[e._v("number")]),t("br"),e._v("\nGets the low 32 bits as a signed integer.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("getLowBitsUnsigned")]),e._v("(): "),t("code",[e._v("number")]),t("br"),e._v("\nGets the low 32 bits as an unsigned integer.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("getNumBitsAbs")]),e._v("(): "),t("code",[e._v("number")]),t("br"),e._v("\nGets the number of bits needed to represent the absolute value of this Long.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("greaterThan")]),e._v("/"),t("strong",[e._v("gt")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is greater than the specified's.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("greaterThanOrEqual")]),e._v("/"),t("strong",[e._v("gte")]),e._v("/"),t("strong",[e._v("ge")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is greater than or equal the specified's.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("isEven")]),e._v("(): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is even.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("isNegative")]),e._v("(): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is negative.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("isOdd")]),e._v("(): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is odd.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("isPositive")]),e._v("(): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is positive.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("isZero")]),e._v("/"),t("strong",[e._v("eqz")]),e._v("(): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value equals zero.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("lessThan")]),e._v("/"),t("strong",[e._v("lt")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is less than the specified's.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("lessThanOrEqual")]),e._v("/"),t("strong",[e._v("lte")]),e._v("/"),t("strong",[e._v("le")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value is less than or equal the specified's.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("modulo")]),e._v("/"),t("strong",[e._v("mod")]),e._v("/"),t("strong",[e._v("rem")]),e._v("(divisor: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns this Long modulo the specified.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("multiply")]),e._v("/"),t("strong",[e._v("mul")]),e._v("(multiplier: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns the product of this and the specified Long.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("negate")]),e._v("/"),t("strong",[e._v("neg")]),e._v("(): "),t("code",[e._v("Long")]),t("br"),e._v("\nNegates this Long's value.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("not")]),e._v("(): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns the bitwise NOT of this Long.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("notEquals")]),e._v("/"),t("strong",[e._v("neq")]),e._v("/"),t("strong",[e._v("ne")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("boolean")]),t("br"),e._v("\nTests if this Long's value differs from the specified's.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("or")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns the bitwise OR of this Long and the specified.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("shiftLeft")]),e._v("/"),t("strong",[e._v("shl")]),e._v("(numBits: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns this Long with bits shifted to the left by the given amount.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("shiftRight")]),e._v("/"),t("strong",[e._v("shr")]),e._v("(numBits: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns this Long with bits arithmetically shifted to the right by the given amount.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("shiftRightUnsigned")]),e._v("/"),t("strong",[e._v("shru")]),e._v("/"),t("strong",[e._v("shr_u")]),e._v("(numBits: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns this Long with bits logically shifted to the right by the given amount.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("rotateLeft")]),e._v("/"),t("strong",[e._v("rotl")]),e._v("(numBits: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns this Long with bits rotated to the left by the given amount.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("rotateRight")]),e._v("/"),t("strong",[e._v("rotr")]),e._v("(numBits: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns this Long with bits rotated to the right by the given amount.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("subtract")]),e._v("/"),t("strong",[e._v("sub")]),e._v("(subtrahend: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns the difference of this and the specified Long.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toBytes")]),e._v("(le?: "),t("code",[e._v("boolean")]),e._v("): "),t("code",[e._v("number[]")]),t("br"),e._v("\nConverts this Long to its byte representation.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toBytesLE")]),e._v("(): "),t("code",[e._v("number[]")]),t("br"),e._v("\nConverts this Long to its little endian byte representation.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toBytesBE")]),e._v("(): "),t("code",[e._v("number[]")]),t("br"),e._v("\nConverts this Long to its big endian byte representation.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toInt")]),e._v("(): "),t("code",[e._v("number")]),t("br"),e._v("\nConverts the Long to a 32 bit integer, assuming it is a 32 bit integer.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toNumber")]),e._v("(): "),t("code",[e._v("number")]),t("br"),e._v("\nConverts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toSigned")]),e._v("(): "),t("code",[e._v("Long")]),t("br"),e._v("\nConverts this Long to signed.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toString")]),e._v("(radix?: "),t("code",[e._v("number")]),e._v("): "),t("code",[e._v("string")]),t("br"),e._v("\nConverts the Long to a string written in the specified radix.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("toUnsigned")]),e._v("(): "),t("code",[e._v("Long")]),t("br"),e._v("\nConverts this Long to unsigned.")])]),e._v(" "),t("li",[t("p",[e._v("Long#"),t("strong",[e._v("xor")]),e._v("(other: "),t("code",[e._v("Long | number | string")]),e._v("): "),t("code",[e._v("Long")]),t("br"),e._v("\nReturns the bitwise XOR of this Long and the given one.")])])]),e._v(" "),t("h2",{attrs:{id:"webassembly-support"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webassembly-support"}},[e._v("#")]),e._v(" WebAssembly support")]),e._v(" "),t("p",[t("a",{attrs:{href:"http://webassembly.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebAssembly"),t("OutboundLink")],1),e._v(" supports 64-bit integer arithmetic out of the box, hence a "),t("a",{attrs:{href:"./src/wasm.wat"}},[e._v("tiny WebAssembly module")]),e._v(" is used to compute operations like multiplication, division and remainder more efficiently (slow operations like division are around twice as fast), falling back to floating point based computations in JavaScript where WebAssembly is not yet supported, e.g., in older versions of node.")]),e._v(" "),t("h2",{attrs:{id:"building"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#building"}},[e._v("#")]),e._v(" Building")]),e._v(" "),t("p",[e._v("To build an UMD bundle to "),t("code",[e._v("dist/long.js")]),e._v(", run:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$> npm install\n$> npm run build\n")])])]),t("p",[e._v("Running the "),t("a",{attrs:{href:"./tests"}},[e._v("tests")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$> npm test\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);